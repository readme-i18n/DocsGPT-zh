---

title: 通过 API 与智能体交互
description: 了解如何使用流式和非流式 API 端点以编程方式与 DocsGPT 智能体进行交互。
---

import { Callout, Tabs } from 'nextra/components';

# 通过 API 与智能体交互

DocsGPT 智能体可通过专用 API 以编程方式访问，使您能够将其专业化能力集成到自己的应用程序、脚本和工作流中。本指南介绍与智能体交互的两种主要方法：用于实时响应的流式 API 和用于获取单一整合答案的非流式 API。

当您使用为特定智能体生成的 API 密钥时，无需传递 `prompt`、`tools` 等参数。智能体的配置（包括其提示词、选定工具和知识源）已与其唯一的 API 密钥关联。

### API 端点

- **非流式:** `http://localhost:7091/api/answer`
- **流式:** `http://localhost:7091/stream`

<Callout type="info">
对于 DocsGPT Cloud 服务，请使用 `https://gptcloud.arc53.com/` 作为基础 URL。
</Callout>

如需更多技术细节，您可以查阅云端版本或本地实例提供的 API Swagger 文档。

---

## 非流式 API (`/api/answer`)

这是一个标准的同步端点。它会等待代理完全处理请求后返回一个包含完整答案的单一JSON对象。这是最简单的方法，非常适合不需要实时数据推送的后端处理流程。

### 请求

-   **端点:** `/api/answer`
-   **方法:** `POST`
-   **载荷:**
    -   `question` (字符串，必填): 用户向代理提出的查询或输入内容。
    -   `api_key` (字符串，必填): 用于交互的代理唯一API密钥。
    -   `history` (字符串，选填): 表示对话历史的JSON字符串，例如 `[{\"prompt\": \"第一个问题\", \"answer\": \"第一个回答\"}]`。

### 响应

包含以下内容的单一JSON对象：

-   `answer`: 代理生成的完整最终答案。
-   `sources`: 代理参考的资料来源列表。
-   `conversation_id`: 该次交互的唯一标识符。

### 示例

<Tabs items={['cURL', 'Python', 'JavaScript']}>
  <Tabs.Tab>
    ```bash
    curl -X POST http://localhost:7091/api/answer \
    -H "Content-Type: application/json" \
    -d '{
        "question": "your question here",
        "api_key": "your_agent_api_key"
    }'
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```python
    import requests

    API_URL = "http://localhost:7091/api/answer"
    API_KEY = "your_agent_api_key"
    QUESTION = "your question here"

    response = requests.post(
        API_URL,
        json={"question": QUESTION, "api_key": API_KEY}
    )

    if response.status_code == 200:
        print(response.json())
    else:
        print(f"Error: {response.status_code}")
        print(response.text)
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript
    const apiUrl = 'http://localhost:7091/api/answer';
    const apiKey = 'your_agent_api_key';
    const question = 'your question here';

    async function getAnswer() {
    try {
        const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ question, api_key: apiKey }),
        });

        if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Failed to fetch answer:", error);
    }
    }

    getAnswer();
    ```
  </Tabs.Tab>
</Tabs>

---

## 流式API (`/stream`)

`/stream` 端点使用服务器发送事件(SSE)实现实时数据推送。这种模式非常适合需要动态展示生成过程的场景，例如实时聊天机器人界面。

### 请求

-   **端点:** `/stream`
-   **方法:** `POST`
-   **载荷:** 与非流式API相同。

### 响应 (SSE流)

数据流由多个 `data:` 事件组成，每个事件包含一个 JSON 对象。客户端应监听这些事件并根据其 `type` 类型进行处理。

**事件类型:**

-   `answer`: 智能体最终回答的一个片段。
-   `source`: 智能体使用的文档或来源。
-   `thought`: 智能体的推理步骤（适用于 ReAct 智能体）。
-   `id`: 交互的唯一 `conversation_id` 标识符。
-   `error`: 错误信息。
-   `end`: 表示数据流结束的最终消息。

### 示例

<Tabs items={['cURL', 'Python', 'JavaScript']}>
  <Tabs.Tab>
    ```bash
    curl -X POST http://localhost:7091/stream \
    -H "Content-Type: application/json" \
    -H "Accept: text/event-stream" \
    -d '{
        "question": "your question here",
        "api_key": "your_agent_api_key"
    }'
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```python
    import requests
    import json

    API_URL = "http://localhost:7091/stream"
    payload = {
        "question": "your question here",
        "api_key": "your_agent_api_key"
    }

    with requests.post(API_URL, json=payload, stream=True) as r:
        for line in r.iter_lines():
            if line:
                decoded_line = line.decode('utf-8')
                if decoded_line.startswith('data: '):
                    try:
                        data = json.loads(decoded_line[6:])
                        print(data)
                    except json.JSONDecodeError:
                        pass
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript
    const apiUrl = 'http://localhost:7091/stream';
    const apiKey = 'your_agent_api_key';
    const question = 'your question here';

    async function getStream() {
    try {
        const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream'
        },
        // Corrected line: 'apiKey' is changed to 'api_key'
        body: JSON.stringify({ question, api_key: apiKey }),
        });

        if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        // Note: This parsing method assumes each chunk contains whole lines.
        // For a more robust production implementation, buffer the chunks
        // and process them line by line.
        const lines = chunk.split('\n');
        
        for (const line of lines) {
            if (line.startsWith('data: ')) {
            try {
                const data = JSON.parse(line.substring(6));
                console.log(data);
            } catch (e) {
                console.error("Failed to parse JSON from SSE event:", e);
            }
            }
        }
        }
    } catch (error) {
        console.error("Failed to fetch stream:", error);
    }
    }

    getStream();
    ```
  </Tabs.Tab>
</Tabs>